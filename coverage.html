
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>shortener: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/sub3er0/urlShorteningService/cmd/shortener/main.go (0.0%)</option>
				
				<option value="file1">github.com/sub3er0/urlShorteningService/internal/config/config.go (100.0%)</option>
				
				<option value="file2">github.com/sub3er0/urlShorteningService/internal/cookie/authMiddleware.go (100.0%)</option>
				
				<option value="file3">github.com/sub3er0/urlShorteningService/internal/cookie/cookieHandler.go (91.9%)</option>
				
				<option value="file4">github.com/sub3er0/urlShorteningService/internal/gzip/gzip.go (0.0%)</option>
				
				<option value="file5">github.com/sub3er0/urlShorteningService/internal/logger/serverLogger.go (0.0%)</option>
				
				<option value="file6">github.com/sub3er0/urlShorteningService/internal/random/http.go (0.0%)</option>
				
				<option value="file7">github.com/sub3er0/urlShorteningService/internal/random/port.go (0.0%)</option>
				
				<option value="file8">github.com/sub3er0/urlShorteningService/internal/random/source.go (0.0%)</option>
				
				<option value="file9">github.com/sub3er0/urlShorteningService/internal/random/string.go (0.0%)</option>
				
				<option value="file10">github.com/sub3er0/urlShorteningService/internal/repository/urlRepository.go (0.0%)</option>
				
				<option value="file11">github.com/sub3er0/urlShorteningService/internal/repository/userRepository.go (0.0%)</option>
				
				<option value="file12">github.com/sub3er0/urlShorteningService/internal/shortener/shortener.go (79.1%)</option>
				
				<option value="file13">github.com/sub3er0/urlShorteningService/internal/storage/FileStorage.go (0.0%)</option>
				
				<option value="file14">github.com/sub3er0/urlShorteningService/internal/storage/InMemoryStorage.go (0.0%)</option>
				
				<option value="file15">github.com/sub3er0/urlShorteningService/internal/storage/urlStorage.go (0.0%)</option>
				
				<option value="file16">github.com/sub3er0/urlShorteningService/internal/storage/userStorage.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "github.com/go-chi/chi/v5"
        "github.com/sub3er0/urlShorteningService/internal/config"
        "github.com/sub3er0/urlShorteningService/internal/cookie"
        "github.com/sub3er0/urlShorteningService/internal/gzip"
        "github.com/sub3er0/urlShorteningService/internal/logger"
        "github.com/sub3er0/urlShorteningService/internal/repository"
        "github.com/sub3er0/urlShorteningService/internal/shortener"
        "github.com/sub3er0/urlShorteningService/internal/storage"
        "go.uber.org/zap"
        "gorm.io/driver/postgres"
        "gorm.io/gorm"
        "log"
        "net/http"
        "os"
        "os/signal"
        "time"
)

var shortenerInstance *shortener.URLShortener

func main() <span class="cov0" title="0">{
        cfg, err := config.InitConfig()

        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error while initializing config: %v", err)
        }</span>

        <span class="cov0" title="0">var dataUrlsStorage storage.URLStorageInterface
        var dataUsersStorage storage.UserStorageInterface

        if cfg.DatabaseDsn != "" </span><span class="cov0" title="0">{
                dsn := cfg.DatabaseDsn
                db, err := gorm.Open(postgres.Open(dsn), &amp;gorm.Config{})

                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to connect database: %v", err)
                }</span>

                <span class="cov0" title="0">err = db.AutoMigrate(storage.URL{})

                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to connect database: %v", err)
                }</span>

                <span class="cov0" title="0">err = db.AutoMigrate(storage.UserCookie{})

                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to connect database: %v", err)
                }</span>

                <span class="cov0" title="0">dataUrlsStorage = &amp;storage.URLStorage{}
                dataUrlsStorage.Init(cfg.DatabaseDsn)
                defer dataUrlsStorage.Close()

                dataUsersStorage = &amp;storage.UsersStorage{}
                dataUsersStorage.Init(cfg.DatabaseDsn)
                defer dataUsersStorage.Close()</span>
        } else<span class="cov0" title="0"> if cfg.FileStoragePath != "" </span><span class="cov0" title="0">{
                dataUrlsStorage = &amp;storage.FileStorage{FileStoragePath: cfg.FileStoragePath}
                dataUsersStorage = &amp;storage.FileStorage{FileStoragePath: cfg.FileStoragePath}
        }</span> else<span class="cov0" title="0"> {
                dataUrlsStorage = &amp;storage.InMemoryStorage{Urls: make(map[string]string)}
                dataUsersStorage = &amp;storage.InMemoryStorage{Urls: make(map[string]string)}
        }</span>

        <span class="cov0" title="0">cookieManager := cookie.CookieManager{
                Storage: dataUsersStorage,
        }

        var userRepository repository.UserRepositoryInterface
        var urlRepository repository.UrlRepositoryInterface

        urlRepository = &amp;repository.UrlRepository{Storage: dataUrlsStorage}
        userRepository = &amp;repository.UserRepository{Storage: dataUsersStorage}

        shortenerInstance = &amp;shortener.URLShortener{
                UserRepository: userRepository,
                UrlRepository:  urlRepository,
                ServerAddress:  cfg.ServerAddress,
                BaseURL:        cfg.BaseURL,
                CookieManager:  &amp;cookieManager,
                RemoveChan:     make(chan string),
        }

        go shortenerInstance.Worker()

        zapLogger, err := zap.NewDevelopment()

        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error creating logger: %s", err)
        }</span>

        <span class="cov0" title="0">defer zapLogger.Sync()
        logger.Sugar = *zapLogger.Sugar()
        r := chi.NewRouter()
        r.Use(logger.RequestLogger)
        r.Use(gzip.RequestDecompressor)
        r.With(cookieManager.CookieHandler).Route("/", func(r chi.Router) </span><span class="cov0" title="0">{
                r.Post("/", shortenerInstance.PostHandler)
                r.Get("/{id}", shortenerInstance.GetHandler)
                r.Post("/api/shorten", shortenerInstance.JSONPostHandler)
                r.Post("/api/shorten/batch", shortenerInstance.JSONBatchHandler)

                r.With(cookieManager.AuthMiddleware).Get("/api/user/urls", shortenerInstance.GetUserUrls)
                r.With(cookieManager.AuthMiddleware).Delete("/api/user/urls", shortenerInstance.DeleteUserUrls)
        }</span>)

        <span class="cov0" title="0">r.Get("/ping", shortenerInstance.PingHandler)

        srv := &amp;http.Server{
                Addr:    cfg.ServerAddress,
                Handler: r,
        }

        go func() </span><span class="cov0" title="0">{
                if err := srv.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Fatalf("Error starting server: %s", err)
                }</span>
        }()

        <span class="cov0" title="0">stop := make(chan os.Signal, 1)
        signal.Notify(stop, os.Interrupt)

        &lt;-stop

        log.Println("Shutting down server...")

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        if err := srv.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error shutting down server: %s", err)
        }</span>

        <span class="cov0" title="0">log.Println("Server has exited.")</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "flag"
        "fmt"
        "os"
)

type Config struct {
        ServerAddress   string
        BaseURL         string
        FileStoragePath string
        DatabaseDsn     string
}

var isParsed bool

func InitConfig() (*Config, error) <span class="cov8" title="1">{
        cfg := &amp;Config{}

        if !isParsed </span><span class="cov8" title="1">{
                flag.StringVar(&amp;cfg.BaseURL, "b", "http://localhost:8080/", "Базовый адрес для сокращенных URL")
                flag.StringVar(&amp;cfg.ServerAddress, "a", "localhost:8080", "Адрес HTTP-сервера")
                flag.StringVar(&amp;cfg.FileStoragePath, "f", "", "Путь до файла")
                flag.StringVar(
                        &amp;cfg.DatabaseDsn,
                        "d", "",
                        "Строка подключения к базе данных")

                flag.Parse()
                isParsed = true
        }</span>

        <span class="cov8" title="1">if ServerAddress := os.Getenv("SERVER_ADDRESS"); ServerAddress != "" </span><span class="cov8" title="1">{
                cfg.ServerAddress = ServerAddress
        }</span>

        <span class="cov8" title="1">if BaseURL := os.Getenv("BASE_URL"); BaseURL != "" </span><span class="cov8" title="1">{
                cfg.BaseURL = BaseURL
        }</span>

        <span class="cov8" title="1">if FileStoragePath := os.Getenv("FILE_STORAGE_PATH"); FileStoragePath != "" </span><span class="cov8" title="1">{
                cfg.FileStoragePath = FileStoragePath
        }</span>

        <span class="cov8" title="1">if DatabaseDsn := os.Getenv("DATABASE_DSN"); DatabaseDsn != "" </span><span class="cov8" title="1">{
                cfg.DatabaseDsn = DatabaseDsn
        }</span>

        <span class="cov8" title="1">if cfg.ServerAddress == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("ServerAddress is required")
        }</span>

        <span class="cov8" title="1">if cfg.BaseURL == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("BaseURL is required")
        }</span>

        <span class="cov8" title="1">return cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package cookie

import (
        "net/http"
)

func (cm *CookieManager) AuthMiddleware(h http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                cookie, err := r.Cookie(cookieName)
                if err != nil || !verifyCookie(cookie.Value) </span><span class="cov8" title="1">{
                        http.Error(w, "Unauthorized", http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov8" title="1">userID, _ := getUserIDFromCookie(cookie.Value)
                isUserExist := cm.Storage.IsUserExist(userID)

                if !isUserExist </span><span class="cov8" title="1">{
                        http.Error(w, "Unauthorized", http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov8" title="1">h.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package cookie

import (
        "crypto/hmac"
        "crypto/rand"
        "crypto/sha256"
        "encoding/base64"
        "github.com/sub3er0/urlShorteningService/internal/storage"
        "net/http"
        "strings"
        "time"
)

type CookieManager struct {
        Storage           storage.UserStorageInterface
        ActualCookieValue string
}

type CookieManagerInterface interface {
        CookieHandler(h http.Handler) http.Handler
        AuthMiddleware(h http.Handler) http.Handler
        GetActualCookieValue() string
}

func (cm *CookieManager) GetActualCookieValue() string <span class="cov0" title="0">{
        return cm.ActualCookieValue
}</span>

var (
        secretKey  = []byte("secret_key")
        cookieName = "user_info"
)

func signCookie(data string) string <span class="cov8" title="1">{
        h := hmac.New(sha256.New, secretKey)
        h.Write([]byte(data))
        signature := h.Sum(nil)

        return base64.RawURLEncoding.EncodeToString(signature)
}</span>

func verifyCookie(str string) bool <span class="cov8" title="1">{
        parts := strings.Split(str, ".")
        if len(parts) != 2 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">dataStr := parts[0]
        sigStr := parts[1]
        expected := signCookie(dataStr)

        return sigStr == expected</span>
}

func getUserIDFromCookie(str string) (string, bool) <span class="cov8" title="1">{
        parts := strings.Split(str, ".")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return "", false
        }</span>

        <span class="cov8" title="1">return parts[0], true</span>
}

func generateUserID() string <span class="cov8" title="1">{
        b := make([]byte, 16)
        rand.Read(b)
        return base64.URLEncoding.EncodeToString(b)
}</span>

func (cm *CookieManager) CookieHandler(h http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                cookie, err := r.Cookie(cookieName)
                createNewCookie := false
                var userID string

                if err != nil || !verifyCookie(cookie.Value) </span><span class="cov8" title="1">{
                        createNewCookie = true
                }</span> else<span class="cov8" title="1"> {
                        userID, _ = getUserIDFromCookie(cookie.Value)
                        isUserExist := cm.Storage.IsUserExist(userID)

                        if isUserExist </span><span class="cov8" title="1">{
                                createNewCookie = false
                        }</span> else<span class="cov0" title="0"> {
                                createNewCookie = true
                        }</span>
                }

                <span class="cov8" title="1">if createNewCookie </span><span class="cov8" title="1">{
                        userID = generateUserID()
                        newCookieValue := userID + "." + signCookie(userID)
                        cm.Storage.SaveUser(userID)
                        http.SetCookie(w, &amp;http.Cookie{
                                Name:     cookieName,
                                Value:    newCookieValue,
                                Path:     "/",
                                Expires:  time.Now().AddDate(10, 0, 0),
                                HttpOnly: true,
                                Secure:   false,
                        })
                }</span>

                <span class="cov8" title="1">cm.ActualCookieValue = userID
                h.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package gzip

import (
        "compress/gzip"
        "io"
        "log"
        "net/http"
        "strings"
)

var AllowedContentTypes = []string{"application/json", "text/html"}

type gzipResponseWriter struct {
        w  http.ResponseWriter
        gz *gzip.Writer
}

func (rw *gzipResponseWriter) Header() http.Header <span class="cov0" title="0">{
        return rw.w.Header()
}</span>

func (rw *gzipResponseWriter) Write(b []byte) (int, error) <span class="cov0" title="0">{
        return rw.gz.Write(b)
}</span>

func (rw *gzipResponseWriter) WriteHeader(statusCode int) <span class="cov0" title="0">{
        rw.w.WriteHeader(statusCode)
}</span>

func RequestDecompressor(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                rw := w

                // Проверка на сжатие ответа
                if strings.Contains(r.Header.Get("Accept-Encoding"), "gzip") &amp;&amp;
                        contains(r.Header.Get("Content-Type"), AllowedContentTypes) </span><span class="cov0" title="0">{
                        gz := gzip.NewWriter(w)
                        defer func(gz *gzip.Writer) </span><span class="cov0" title="0">{
                                err := gz.Close()

                                if err != nil </span><span class="cov0" title="0">{
                                        log.Printf("Error closing gzip.Writer: %s", err)
                                        http.Error(rw, "Internal Server Error", http.StatusInternalServerError)

                                        return
                                }</span>
                        }(gz)

                        <span class="cov0" title="0">rw = &amp;gzipResponseWriter{w: w, gz: gz}
                        rw.Header().Set("Content-Encoding", "gzip")</span>
                }

                // Распаковка запроса
                <span class="cov0" title="0">if strings.Contains(r.Header.Get("Content-Encoding"), "gzip") </span><span class="cov0" title="0">{
                        reader, err := gzip.NewReader(r.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Error decompressing request body %s", err)
                                http.Error(rw, "Error decompressing request body", http.StatusInternalServerError)

                                return
                        }</span>
                        <span class="cov0" title="0">defer reader.Close()
                        r.Body = io.NopCloser(reader)</span>
                }

                <span class="cov0" title="0">next.ServeHTTP(rw, r)</span>
        })
}

func contains(target string, list []string) bool <span class="cov0" title="0">{
        for _, v := range list </span><span class="cov0" title="0">{
                if v == target </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package logger

import (
        "fmt"
        "github.com/go-chi/chi/v5/middleware"
        "go.uber.org/zap"
        "net/http"
        "time"
)

var Sugar zap.SugaredLogger

func RequestLogger(h http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                start := time.Now()
                uri := r.RequestURI
                method := r.Method
                rw := middleware.NewWrapResponseWriter(w, r.ProtoMajor)

                defer func() </span><span class="cov0" title="0">{
                        Sugar.Infoln(
                                fmt.Sprintf("Response: Status=%d", rw.Status()),
                                fmt.Sprintf("ContentLength=%d", rw.BytesWritten()),
                        )

                        duration := time.Since(start)
                        Sugar.Infoln(
                                "uri", uri,
                                "method", method,
                                "duration", duration,
                        )
                }</span>()

                <span class="cov0" title="0">h.ServeHTTP(rw, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package random

import (
        "net/url"
        "strings"
)

// URL returns random valid HTTP URL in a form of url.URL
func URL() *url.URL <span class="cov0" title="0">{
        var res url.URL

        // generate SCHEME
        res.Scheme = "http"
        res.Host = Domain(5, 15)

        for i := 0; i &lt; rnd.Intn(4); i++ </span><span class="cov0" title="0">{
                res.Path += "/" + strings.ToLower(ASCIIString(5, 15))
        }</span>
        <span class="cov0" title="0">return &amp;res</span>
}

// Domain returns random valid domain
func Domain(minLen, maxLen int, zones ...string) string <span class="cov0" title="0">{
        if minLen == 0 </span><span class="cov0" title="0">{
                minLen = 5
        }</span>
        <span class="cov0" title="0">if maxLen == 0 </span><span class="cov0" title="0">{
                maxLen = 15
        }</span>

        // generate ZONE
        <span class="cov0" title="0">var zone string
        switch len(zones) </span>{
        case 1:<span class="cov0" title="0">
                zone = zones[0]</span>
        case 0:<span class="cov0" title="0">
                zones = []string{"com", "ru", "net", "biz", "yandex"}
                zone = zones[rnd.Intn(len(zones))]</span>
        default:<span class="cov0" title="0">
                zone = zones[rnd.Intn(len(zones))]</span>
        }

        // generate HOST
        <span class="cov0" title="0">host := strings.ToLower(ASCIIString(minLen, maxLen))
        return host + "." + strings.TrimLeft(zone, ".")</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package random

import (
        "net"
)

// Port returns random port in given range
func Port(from, to int) int <span class="cov0" title="0">{
        if from &lt;= 0 </span><span class="cov0" title="0">{
                from = 1024
        }</span>
        <span class="cov0" title="0">if to &lt;= 0 || to &gt; 65535 </span><span class="cov0" title="0">{
                to = 65535
        }</span>
        <span class="cov0" title="0">return rnd.Intn(to-from) + from</span>
}

// UnusedPort returns random unused port
func UnusedPort() (int, error) <span class="cov0" title="0">{
        addr, err := net.ResolveTCPAddr("tcp", "localhost:0")
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">l, err := net.ListenTCP("tcp", addr)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">defer l.Close()
        return l.Addr().(*net.TCPAddr).Port, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package random

import (
        "crypto/rand"
        "encoding/binary"
        "io"
        mathrand "math/rand"
)

// rnd generates new random generator with new source for each binary call
var rnd = func() *mathrand.Rand <span class="cov0" title="0">{
        buf := make([]byte, 8)
        _, err := io.ReadFull(rand.Reader, buf)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">src := mathrand.NewSource(int64(binary.LittleEndian.Uint64(buf)))
        return mathrand.New(src)</span>
}()
</pre>
		
		<pre class="file" id="file9" style="display: none">package random

// ASCIIString generates random ASCII string
func ASCIIString(minLen, maxLen int) string <span class="cov0" title="0">{
        var letters = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ"

        slen := rnd.Intn(maxLen-minLen) + minLen

        s := make([]byte, 0, slen)
        i := 0
        for len(s) &lt; slen </span><span class="cov0" title="0">{
                idx := rnd.Intn(len(letters) - 1)
                char := letters[idx]
                if i == 0 &amp;&amp; '0' &lt;= char &amp;&amp; char &lt;= '9' </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">s = append(s, char)
                i++</span>
        }

        <span class="cov0" title="0">return string(s)</span>
}

// DigitString generates random string consists of digits
func DigitString(minLen, maxLen int) string <span class="cov0" title="0">{
        var letters = "0123456789"

        slen := rnd.Intn(maxLen-minLen) + minLen

        s := make([]byte, 0, slen)
        i := 0
        for len(s) &lt; slen </span><span class="cov0" title="0">{
                idx := rnd.Intn(len(letters) - 1)
                char := letters[idx]
                if i == 0 &amp;&amp; '0' == char </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">s = append(s, char)
                i++</span>
        }

        <span class="cov0" title="0">return string(s)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package repository

import "github.com/sub3er0/urlShorteningService/internal/storage"

type UrlRepositoryInterface interface {
        GetURL(shortURL string) (storage.GetURLRow, bool)
        GetURLCount() int
        GetShortURL(URL string) (string, error)
        Save(ShortURL string, URL string, userID string) error
        LoadData() ([]storage.DataStorageRow, error)
        Ping() bool
        SaveBatch(dataStorageRows []storage.DataStorageRow) error
}

type UrlRepository struct {
        Storage storage.URLStorageInterface
}

func (ur *UrlRepository) GetStorage() storage.URLStorageInterface <span class="cov0" title="0">{
        return ur.Storage
}</span>

func (ur *UrlRepository) GetURL(shortURL string) (storage.GetURLRow, bool) <span class="cov0" title="0">{
        return ur.Storage.GetURL(shortURL)
}</span>

// GetURLCount возвращает количество URL.
func (ur *UrlRepository) GetURLCount() int <span class="cov0" title="0">{
        return ur.Storage.GetURLCount()
}</span>

// GetShortURL возвращает короткий URL, если он существует.
func (ur *UrlRepository) GetShortURL(URL string) (string, error) <span class="cov0" title="0">{
        return ur.Storage.GetShortURL(URL)
}</span>

// Save сохраняет короткий URL и оригинальный URL для пользователя.
func (ur *UrlRepository) Save(ShortURL string, URL string, userID string) error <span class="cov0" title="0">{
        return ur.Storage.Save(ShortURL, URL, userID)
}</span>

// LoadData загружает данные из хранилища.
func (ur *UrlRepository) LoadData() ([]storage.DataStorageRow, error) <span class="cov0" title="0">{
        return ur.Storage.LoadData()
}</span>

// Ping проверяет доступность хранилища.
func (ur *UrlRepository) Ping() bool <span class="cov0" title="0">{
        return ur.Storage.Ping()
}</span>

// SaveBatch сохраняет пакет данных в хранилище.
func (ur *UrlRepository) SaveBatch(dataStorageRows []storage.DataStorageRow) error <span class="cov0" title="0">{
        return ur.Storage.SaveBatch(dataStorageRows)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package repository

import "github.com/sub3er0/urlShorteningService/internal/storage"

type UserRepositoryInterface interface {
        IsUserExist(uniqueID string) bool
        SaveUser(uniqueID string) error
        GetUserUrls(uniqueID string) ([]storage.UserUrlsResponseBodyItem, error)
        DeleteUserUrls(uniqueID string, shortURLS []string) error
}

// UserRepository реализует UserRepositoryInterface.
type UserRepository struct {
        Storage storage.UserStorageInterface
}

// IsUserExist проверяет, существует ли пользователь по уникальному ID.
func (ur *UserRepository) IsUserExist(uniqueID string) bool <span class="cov0" title="0">{
        return false
}</span>

// SaveUser сохраняет пользователя с указанным уникальным ID.
func (ur *UserRepository) SaveUser(uniqueID string) error <span class="cov0" title="0">{
        return nil
}</span>

// GetUserUrls возвращает список URL-адресов для указанного уникального ID пользователя.
func (ur *UserRepository) GetUserUrls(uniqueID string) ([]storage.UserUrlsResponseBodyItem, error) <span class="cov0" title="0">{
        return []storage.UserUrlsResponseBodyItem{}, nil
}</span>

// DeleteUserUrls удаляет указанные URL-адреса для указанного уникального ID пользователя.
func (ur *UserRepository) DeleteUserUrls(uniqueID string, shortURLS []string) error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package shortener

import (
        "encoding/json"
        "github.com/pkg/errors"
        "github.com/sub3er0/urlShorteningService/internal/cookie"
        "github.com/sub3er0/urlShorteningService/internal/repository"
        "github.com/sub3er0/urlShorteningService/internal/storage"
        "io"
        "log"
        "math/rand"
        "net/http"
        "net/url"
        "sync"
)

// URLShortener Структура URLShortener, использующая интерфейс хранения
type URLShortener struct {
        UrlRepository  repository.UrlRepositoryInterface
        UserRepository repository.UserRepositoryInterface
        ServerAddress  string
        BaseURL        string
        CookieManager  cookie.CookieManagerInterface
        RemoveChan     chan string
        wg             sync.WaitGroup
}

// URLShortenerInterface - интерфейс для работы с сокращениями URL.
type URLShortenerInterface interface {
        // GetHandler Получает короткий URL из репозитория
        GetHandler(w http.ResponseWriter, r *http.Request)

        // PingHandler Проверяет состояние соединения с репозиторием
        PingHandler(w http.ResponseWriter, r *http.Request)

        // JSONPostHandler Обрабатывает запрос на создание короткого URL в формате JSON
        JSONPostHandler(w http.ResponseWriter, r *http.Request)

        // JSONBatchHandler Обрабатывает пакетные запросы на создание сокращенных URL
        JSONBatchHandler(w http.ResponseWriter, r *http.Request)

        // GetUserUrls Получает URL пользователя
        GetUserUrls(w http.ResponseWriter, r *http.Request)

        // DeleteUserUrls Удаляет короткие URL
        DeleteUserUrls(w http.ResponseWriter, r *http.Request)

        // Worker Удаляет короткие URL
        Worker()
}

type JSONResponseBody struct {
        Result string `json:"result"`
}

type RequestBody struct {
        URL string `json:"url"`
}

type DeleteRequestBody struct {
        ShortURL string `json:"short_url"`
}

type BatchRequestBody struct {
        CorrelationID string `json:"correlation_id"`
        OriginalURL   string `json:"original_url"`
}

type BatchResponseBodyItem struct {
        CorrelationID string `json:"correlation_id"`
        ShortURL      string `json:"short_url"`
}

type ExistValueError struct {
        Text string
}

var ErrShortURLExists = &amp;ExistValueError{Text: "ShortURL already exists"}

func (us *URLShortener) Worker() <span class="cov8" title="1">{
        batchSize := 1
        shortURLs := make([]string, 0, batchSize)

        for urlFromChan := range us.RemoveChan </span><span class="cov8" title="1">{
                shortURLs = append(shortURLs, urlFromChan)

                if len(shortURLs) &gt;= batchSize </span><span class="cov8" title="1">{
                        err := us.UserRepository.DeleteUserUrls(us.CookieManager.GetActualCookieValue(), shortURLs)
                        if err != nil </span><span class="cov8" title="1">{
                                log.Printf("Error while deleting urls")
                        }</span>
                        <span class="cov8" title="1">shortURLs = shortURLs[:0]</span>
                }
        }

        <span class="cov8" title="1">if len(shortURLs) &gt; 0 </span><span class="cov0" title="0">{
                if err := us.UserRepository.DeleteUserUrls(us.CookieManager.GetActualCookieValue(), shortURLs); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error while deleting remaining URLs: %v", err)
                }</span>
        }
}

func (e *ExistValueError) Error() string <span class="cov0" title="0">{
        return e.Text
}</span>

func (us *URLShortener) getShortURL(URL string) (string, error) <span class="cov8" title="1">{
        return us.UrlRepository.GetShortURL(URL)
}</span>

func (us *URLShortener) GetHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        id := r.PathValue("id")

        storedURL, ok := us.UrlRepository.GetURL(id)

        if !ok </span><span class="cov8" title="1">{
                http.Error(w, "NotFound", http.StatusNotFound)
        }</span> else<span class="cov8" title="1"> if !storedURL.IsDeleted </span><span class="cov8" title="1">{
                w.Header().Set("Location", storedURL.URL)
                w.WriteHeader(http.StatusTemporaryRedirect)
        }</span> else<span class="cov8" title="1"> if storedURL.IsDeleted </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusGone)
        }</span>

        <span class="cov8" title="1">return</span>
}

func (us *URLShortener) PingHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ok := us.UrlRepository.Ping()

        if ok </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusOK)
                return
        }</span> else<span class="cov8" title="1"> {
                http.Error(w, "Connection error", http.StatusInternalServerError)
        }</span>
}

func (us *URLShortener) JSONPostHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        body, err := io.ReadAll(r.Body)

        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">var requestBody RequestBody
        err = json.Unmarshal(body, &amp;requestBody)

        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">bodyURL, err := url.ParseRequestURI(requestBody.URL)

        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">shortKey, err := us.getShortKey(bodyURL.String())

        var responseBody JSONResponseBody
        responseBody.Result = shortKey

        if errors.Is(err, ErrShortURLExists) </span><span class="cov0" title="0">{
                err = us.buildJSONResponse(w, responseBody, true)
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Internal Server Error", http.StatusInternalServerError)
                return
        }</span> else<span class="cov8" title="1"> {
                err = us.buildJSONResponse(w, responseBody, false)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Internal Server Error", http.StatusInternalServerError)
                return
        }</span>
}

func (us *URLShortener) JSONBatchHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        body, err := io.ReadAll(r.Body)

        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">var requestBody []BatchRequestBody
        err = json.Unmarshal(body, &amp;requestBody)

        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">var responseBodyBatch []BatchResponseBodyItem
        var dataStorageRows []storage.DataStorageRow

        for _, requestBodyRow := range requestBody </span><span class="cov8" title="1">{
                shortKey, err := us.getShortURL(requestBodyRow.OriginalURL)

                if err != nil </span><span class="cov8" title="1">{
                        shortKey = generateShortKey()
                }</span>

                <span class="cov8" title="1">responseBody := BatchResponseBodyItem{
                        CorrelationID: requestBodyRow.CorrelationID,
                        ShortURL:      us.BaseURL + shortKey,
                }

                if errors.Is(err, ErrShortURLExists) </span><span class="cov0" title="0">{
                        responseBodyBatch = append(responseBodyBatch, responseBody)
                        continue</span>
                }

                <span class="cov8" title="1">responseBodyBatch = append(responseBodyBatch, responseBody)

                dataStorageRow := storage.DataStorageRow{
                        ShortURL: shortKey,
                        URL:      requestBodyRow.OriginalURL,
                        UserID:   us.CookieManager.GetActualCookieValue(),
                }
                dataStorageRows = append(dataStorageRows, dataStorageRow)

                if len(responseBodyBatch) == 1000 </span><span class="cov0" title="0">{
                        us.saveBatch(w, dataStorageRows)
                        dataStorageRows = dataStorageRows[:0]
                        us.UrlRepository.Save(shortKey, requestBodyRow.OriginalURL, us.CookieManager.GetActualCookieValue())
                }</span>
        }

        <span class="cov8" title="1">if len(dataStorageRows) &gt; 0 </span><span class="cov8" title="1">{
                us.saveBatch(w, dataStorageRows)
        }</span>

        <span class="cov8" title="1">err = us.buildJSONBatchResponse(w, responseBodyBatch)

        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Internal Server Error", http.StatusInternalServerError)
                return
        }</span>
}

func (us *URLShortener) GetUserUrls(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        urls, err := us.UserRepository.GetUserUrls(us.CookieManager.GetActualCookieValue())

        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Internal Server Error", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">if len(urls) == 0 </span><span class="cov8" title="1">{
                http.Error(w, "No Content", http.StatusNoContent)
                return
        }</span>

        <span class="cov8" title="1">err = us.buildAllUserUrlsResponse(w, urls)

        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
}

func (us *URLShortener) saveBatch(w http.ResponseWriter, dataStorageRows []storage.DataStorageRow) <span class="cov8" title="1">{
        err := us.UrlRepository.SaveBatch(dataStorageRows)

        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Internal Server Error", http.StatusInternalServerError)
        }</span>
}

func (us *URLShortener) PostHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        body, err := io.ReadAll(r.Body)

        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">u, err := url.ParseRequestURI(string(body))

        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">postURL := u.String()
        shortKey, err := us.getShortKey(postURL)

        if errors.Is(err, ErrShortURLExists) </span><span class="cov0" title="0">{
                us.buildResponse(w, shortKey, true)
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Internal Server Error", http.StatusBadRequest)
                return
        }</span> else<span class="cov8" title="1"> {
                us.buildResponse(w, shortKey, false)
        }</span>

        <span class="cov8" title="1">defer func(Body io.ReadCloser) </span><span class="cov8" title="1">{
                err := Body.Close()

                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Internal Server Error", http.StatusInternalServerError)
                        return
                }</span>
        }(r.Body)
}

func (us *URLShortener) getShortKey(postURL string) (string, error) <span class="cov8" title="1">{
        shortKey, err := us.UrlRepository.GetShortURL(postURL)

        if err == nil </span><span class="cov0" title="0">{
                return shortKey, ErrShortURLExists
        }</span>

        <span class="cov8" title="1">shortKey = generateShortKey()
        err = us.UrlRepository.Save(shortKey, postURL, us.CookieManager.GetActualCookieValue())

        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">return shortKey, nil</span>
}

func generateShortKey() string <span class="cov8" title="1">{
        const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
        const keyLength = 6

        shortKey := make([]byte, keyLength)

        for i := range shortKey </span><span class="cov8" title="1">{
                shortKey[i] = charset[rand.Intn(len(charset))]
        }</span>

        <span class="cov8" title="1">return string(shortKey)</span>
}

func (us *URLShortener) buildResponse(w http.ResponseWriter, shortKey string, isExist bool) <span class="cov8" title="1">{
        w.Header().Set("content-type", "text/plain")

        if !isExist </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusCreated)
        }</span> else<span class="cov0" title="0"> {
                w.WriteHeader(http.StatusConflict)
        }</span>

        <span class="cov8" title="1">if len(us.BaseURL) &gt; 0 &amp;&amp; us.BaseURL[len(us.BaseURL)-1] != '/' </span><span class="cov0" title="0">{
                us.BaseURL = us.BaseURL + "/"
        }</span>

        <span class="cov8" title="1">_, err := w.Write([]byte(us.BaseURL + shortKey))

        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Internal Server Error", http.StatusInternalServerError)
                return
        }</span>
}

func (us *URLShortener) buildJSONResponse(w http.ResponseWriter, response JSONResponseBody, isExist bool) error <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        if !isExist </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusCreated)
        }</span> else<span class="cov0" title="0"> {
                w.WriteHeader(http.StatusConflict)
        }</span>

        <span class="cov8" title="1">if len(us.BaseURL) &gt; 0 &amp;&amp; us.BaseURL[len(us.BaseURL)-1] != '/' </span><span class="cov0" title="0">{
                us.BaseURL = us.BaseURL + "/"
        }</span>

        <span class="cov8" title="1">response.Result = us.BaseURL + response.Result
        jsonData, err := json.Marshal(response)

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Serialization fail: %v", err)
                return err
        }</span>

        <span class="cov8" title="1">_, err = w.Write(jsonData)

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Write data error: %v", err)
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (us *URLShortener) buildJSONBatchResponse(w http.ResponseWriter, response []BatchResponseBodyItem) error <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)

        jsonData, err := json.Marshal(response)

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Serialization fail: %v", err)
                return err
        }</span>

        <span class="cov8" title="1">_, err = w.Write(jsonData)

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Write data error: %v", err)
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (us *URLShortener) buildAllUserUrlsResponse(w http.ResponseWriter, response []storage.UserUrlsResponseBodyItem) error <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)

        for i := range response </span><span class="cov8" title="1">{
                response[i].ShortURL = us.BaseURL + response[i].ShortURL
        }</span>

        <span class="cov8" title="1">jsonData, err := json.Marshal(response)

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Serialization fail: %v", err)
                return err
        }</span>

        <span class="cov8" title="1">_, err = w.Write(jsonData)

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Write data error: %v", err)
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (us *URLShortener) DeleteUserUrlsBatch(shortURLs []string) <span class="cov8" title="1">{
        batchSize := 100

        for i := 0; i &lt; len(shortURLs); i += batchSize </span><span class="cov8" title="1">{
                end := i + batchSize
                if end &gt; len(shortURLs) </span><span class="cov8" title="1">{
                        end = len(shortURLs)
                }</span>

                <span class="cov8" title="1">urlsBatch := shortURLs[i:end]
                err := us.UserRepository.DeleteUserUrls(us.CookieManager.GetActualCookieValue(), urlsBatch)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error while deleting urls")
                }</span>
        }
}

func (us *URLShortener) DeleteUserUrls(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var shortURLs []string
        err := json.NewDecoder(r.Body).Decode(&amp;shortURLs)

        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">for _, shortURL := range shortURLs </span><span class="cov8" title="1">{
                us.RemoveChan &lt;- shortURL
        }</span>

        <span class="cov8" title="1">w.WriteHeader(http.StatusAccepted)</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package storage

import (
        "bufio"
        "encoding/json"
        "errors"
        "io"
        "log"
        "os"
)

type FileStorage struct {
        FileStoragePath string
}

func (fs *FileStorage) Init(connectionString string) error <span class="cov0" title="0">{
        return nil
}</span>

func (fs *FileStorage) Close() {<span class="cov0" title="0">}</span>

func (fs *FileStorage) SaveBatch(dataStorageRows []DataStorageRow) error <span class="cov0" title="0">{
        urlCount := fs.GetURLCount()
        for i := range dataStorageRows </span><span class="cov0" title="0">{
                urlCount++
                dataStorageRows[i].ID = urlCount
        }</span>

        <span class="cov0" title="0">var jsonRows []byte

        for _, dataStorageRow := range dataStorageRows </span><span class="cov0" title="0">{
                jsonRow, err := json.Marshal(dataStorageRow)
                jsonRows = append(jsonRows, jsonRow...)
                jsonRows = append(jsonRows, '\n')

                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">file, err := os.OpenFile(fs.FileStoragePath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error opening file:  %v\n", err)
                return err
        }</span>

        <span class="cov0" title="0">defer file.Close()

        _, err = file.Write(jsonRows)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (fs *FileStorage) GetURL(shortURL string) (GetURLRow, bool) <span class="cov0" title="0">{
        file, err := os.OpenFile(fs.FileStoragePath, os.O_RDONLY|os.O_CREATE, 0666)
        var getURLRow GetURLRow

        if err != nil </span><span class="cov0" title="0">{
                return getURLRow, false
        }</span>

        <span class="cov0" title="0">defer file.Close()
        reader := bufio.NewReader(file)
        var dataStorageRow DataStorageRow

        for </span><span class="cov0" title="0">{
                data, err := reader.ReadBytes('\n')

                if err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return getURLRow, false
                }</span>

                <span class="cov0" title="0">err = json.Unmarshal(data, &amp;dataStorageRow)

                if err != nil </span><span class="cov0" title="0">{
                        return getURLRow, false
                }</span>

                <span class="cov0" title="0">getURLRow.URL = dataStorageRow.URL
                if dataStorageRow.ShortURL == shortURL </span><span class="cov0" title="0">{
                        return getURLRow, true
                }</span>
        }

        <span class="cov0" title="0">return getURLRow, false</span>
}

func (fs *FileStorage) GetURLCount() int <span class="cov0" title="0">{
        file, err := os.OpenFile(fs.FileStoragePath, os.O_RDONLY|os.O_CREATE, 0666)

        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">defer file.Close()
        reader := bufio.NewReader(file)
        count := 0

        for </span><span class="cov0" title="0">{
                _, err := reader.ReadBytes('\n')

                if err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">count++</span>
        }

        <span class="cov0" title="0">return count</span>
}

func (fs *FileStorage) GetShortURL(URL string) (string, error) <span class="cov0" title="0">{
        file, err := os.OpenFile(fs.FileStoragePath, os.O_RDONLY|os.O_CREATE, 0666)

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">defer file.Close()
        reader := bufio.NewReader(file)
        var dataStorageRow DataStorageRow

        for </span><span class="cov0" title="0">{
                data, err := reader.ReadBytes('\n')

                if err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                <span class="cov0" title="0">err = json.Unmarshal(data, &amp;dataStorageRow)

                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                <span class="cov0" title="0">if dataStorageRow.URL == URL </span><span class="cov0" title="0">{
                        return dataStorageRow.ShortURL, nil
                }</span>
        }

        <span class="cov0" title="0">err = errors.New("short url not found")
        return "", err</span>
}

func (fs *FileStorage) Save(ShortURL string, URL string, userID string) error <span class="cov0" title="0">{
        row := DataStorageRow{
                ID:       fs.GetURLCount(),
                ShortURL: ShortURL,
                URL:      URL,
        }
        jsonRow, err := json.Marshal(row)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">file, err := os.OpenFile(fs.FileStoragePath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error opening file:  %v\n", err)
                return err
        }</span>

        <span class="cov0" title="0">defer file.Close()
        jsonRow = append(jsonRow, '\n')
        _, err = file.Write(jsonRow)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (fs *FileStorage) LoadData() ([]DataStorageRow, error) <span class="cov0" title="0">{
        file, err := os.OpenFile(fs.FileStoragePath, os.O_RDONLY|os.O_CREATE, 0666)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">defer file.Close()
        reader := bufio.NewReader(file)
        var dataStorageRow DataStorageRow
        var dataStorageRows []DataStorageRow

        for </span><span class="cov0" title="0">{
                data, err := reader.ReadBytes('\n')

                if err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">err = json.Unmarshal(data, &amp;dataStorageRow)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">dataStorageRows = append(dataStorageRows, dataStorageRow)</span>
        }

        <span class="cov0" title="0">return dataStorageRows, nil</span>
}

func (fs *FileStorage) Ping() bool <span class="cov0" title="0">{
        return true
}</span>

func (fs *FileStorage) IsUserExist(data string) bool <span class="cov0" title="0">{
        return false
}</span>

func (fs *FileStorage) SaveUser(uniqueID string) error <span class="cov0" title="0">{
        return nil
}</span>

func (fs *FileStorage) GetUserUrls(uniqueID string) ([]UserUrlsResponseBodyItem, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (fs *FileStorage) DeleteUserUrls(uniqueID string, shortURLS []string) error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package storage

import (
        "errors"
)

// InMemoryStorage Пример реализации хранения в памяти
type InMemoryStorage struct {
        Urls map[string]string
}

func (ims *InMemoryStorage) Init(connectionString string) error <span class="cov0" title="0">{
        return nil
}</span>

func (ims *InMemoryStorage) Close() {<span class="cov0" title="0">}</span>

func (ims *InMemoryStorage) SaveBatch(dataStorageRows []DataStorageRow) error <span class="cov0" title="0">{
        for _, row := range dataStorageRows </span><span class="cov0" title="0">{
                ims.Urls[row.ShortURL] = row.URL
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (ims *InMemoryStorage) Save(ShorURL string, URL string, userID string) error <span class="cov0" title="0">{
        ims.Urls[ShorURL] = URL
        return nil
}</span>

func (ims *InMemoryStorage) LoadData() ([]DataStorageRow, error) <span class="cov0" title="0">{
        return make([]DataStorageRow, 0), nil
}</span>

func (ims *InMemoryStorage) GetURL(shortURL string) (GetURLRow, bool) <span class="cov0" title="0">{
        var getURLRow GetURLRow
        var ok bool
        getURLRow.URL, ok = ims.Urls[shortURL]

        return getURLRow, ok
}</span>

func (ims *InMemoryStorage) GetURLCount() int <span class="cov0" title="0">{
        return len(ims.Urls)
}</span>

func (ims *InMemoryStorage) GetShortURL(URL string) (string, error) <span class="cov0" title="0">{
        err := errors.New("short url not found")

        for k, v := range ims.Urls </span><span class="cov0" title="0">{
                if v == URL </span><span class="cov0" title="0">{
                        return k, nil
                }</span>
        }

        <span class="cov0" title="0">return "", err</span>
}

func (ims *InMemoryStorage) Set(shortURL, longURL string) error <span class="cov0" title="0">{
        ims.Urls[shortURL] = longURL
        return nil
}</span>

func (ims *InMemoryStorage) Ping() bool <span class="cov0" title="0">{
        return true
}</span>

func (ims *InMemoryStorage) IsUserExist(data string) bool <span class="cov0" title="0">{
        return false
}</span>

func (ims *InMemoryStorage) SaveUser(uniqueID string) error <span class="cov0" title="0">{
        return nil
}</span>

func (ims *InMemoryStorage) GetUserUrls(uniqueID string) ([]UserUrlsResponseBodyItem, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (ims *InMemoryStorage) DeleteUserUrls(uniqueID string, shortURLS []string) error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package storage

import (
        "context"
        "errors"
        "fmt"
        "github.com/jackc/pgx/v4"
        "github.com/jackc/pgx/v4/pgxpool"
        "log"
)

type URLStorageInterface interface {
        GetURL(shortURL string) (GetURLRow, bool)
        GetURLCount() int
        GetShortURL(URL string) (string, error)
        Save(ShortURL string, URL string, userID string) error
        LoadData() ([]DataStorageRow, error)
        Ping() bool
        SaveBatch(dataStorageRows []DataStorageRow) error
        Init(connectionString string) error
        Close()
}

// CommandTag - интерфейс для работы с результатами выполнения команд.
type CommandTag interface{}

type URLStorage struct {
        conn DBConnectionInterface
        ctx  context.Context
}

func (us *URLStorage) GetURL(shortURL string) (GetURLRow, bool) <span class="cov0" title="0">{
        var getURLRow GetURLRow
        query := fmt.Sprintf("SELECT url, is_deleted FROM %s WHERE short_url = $1", tableName)
        rows, err := us.conn.Query(us.ctx, query, shortURL)

        if err != nil </span><span class="cov0" title="0">{
                return getURLRow, false
        }</span>

        <span class="cov0" title="0">rowsCount := 0

        for rows.Next() </span><span class="cov0" title="0">{
                if err := rows.Scan(&amp;getURLRow.URL, &amp;getURLRow.IsDeleted); err != nil </span><span class="cov0" title="0">{
                        return getURLRow, false
                }</span>

                <span class="cov0" title="0">rowsCount++</span>
        }

        <span class="cov0" title="0">if rowsCount == 0 </span><span class="cov0" title="0">{
                return getURLRow, false
        }</span>

        <span class="cov0" title="0">return getURLRow, true</span>
}

func (us *URLStorage) GetURLCount() int <span class="cov0" title="0">{
        return 0
}</span>

func (us *URLStorage) GetShortURL(URL string) (string, error) <span class="cov0" title="0">{
        query := fmt.Sprintf("SELECT short_url FROM %s WHERE url = $1", tableName)
        rows, err := us.conn.Query(us.ctx, query, URL)

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">shortURL := ""
        rowsCount := 0

        for rows.Next() </span><span class="cov0" title="0">{
                if err := rows.Scan(&amp;shortURL); err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                <span class="cov0" title="0">rowsCount++</span>
        }

        <span class="cov0" title="0">if rowsCount == 0 </span><span class="cov0" title="0">{
                return "", errors.New("not found")
        }</span>

        <span class="cov0" title="0">return shortURL, nil</span>
}

func (us *URLStorage) Init(connectionString string) error <span class="cov0" title="0">{
        us.ctx = context.Background()
        var err error
        us.conn, err = pgxpool.Connect(us.ctx, connectionString)

        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error while initializing db connection: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (us *URLStorage) Ping() bool <span class="cov0" title="0">{
        if err := us.conn.Ping(us.ctx); err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

func (us *URLStorage) Save(ShortURL string, URL string, userID string) error <span class="cov0" title="0">{
        query := fmt.Sprintf("INSERT INTO %s (short_url, url, user_id) VALUES ($1, $2, $3)", tableName)
        _, err := us.conn.Exec(us.ctx, query, ShortURL, URL, userID)
        return err
}</span>

func (us *URLStorage) LoadData() ([]DataStorageRow, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (us *URLStorage) Close() <span class="cov0" title="0">{
        us.conn.Close()
}</span>

func (us *URLStorage) SaveBatch(dataStorageRows []DataStorageRow) error <span class="cov0" title="0">{
        batch := &amp;pgx.Batch{}
        for _, dataStorageRow := range dataStorageRows </span><span class="cov0" title="0">{
                batch.Queue(
                        "INSERT INTO urls (url, short_url, user_id) VALUES ($1, $2, $3) ON CONFLICT (url, short_url) DO NOTHING",
                        dataStorageRow.URL, dataStorageRow.ShortURL, dataStorageRow.UserID)
        }</span>

        <span class="cov0" title="0">br := us.conn.SendBatch(context.Background(), batch)
        defer br.Close()

        for i := 0; i &lt; len(dataStorageRows); i++ </span><span class="cov0" title="0">{
                _, err := br.Exec()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package storage

import (
        "context"
        "fmt"
        "github.com/jackc/pgx/v4"
        "github.com/jackc/pgx/v4/pgxpool"
        "log"
)

type UserStorageInterface interface {
        IsUserExist(uniqueID string) bool
        SaveUser(uniqueID string) error
        GetUserUrls(uniqueID string) ([]UserUrlsResponseBodyItem, error)
        DeleteUserUrls(uniqueID string, shortURLS []string) error
        Init(connectionString string) error
        Close()
}

type UsersStorage struct {
        conn *pgxpool.Pool
        ctx  context.Context
}

func (us *UsersStorage) IsUserExist(uniqueID string) bool <span class="cov0" title="0">{
        query := "SELECT id FROM users_cookie WHERE user_id = $1"
        rows, err := us.conn.Query(us.ctx, query, uniqueID)

        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">var id int
        var rowsCount int

        for rows.Next() </span><span class="cov0" title="0">{
                if err := rows.Scan(&amp;id); err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov0" title="0">rowsCount++</span>
        }

        <span class="cov0" title="0">return rowsCount &gt; 0</span>
}

func (us *UsersStorage) SaveUser(uniqueID string) error <span class="cov0" title="0">{
        query := "INSERT INTO users_cookie (user_id) VALUES ($1)"
        _, err := us.conn.Exec(us.ctx, query, uniqueID)
        return err
}</span>

func (us *UsersStorage) GetUserUrls(uniqueID string) ([]UserUrlsResponseBodyItem, error) <span class="cov0" title="0">{
        query := fmt.Sprintf("SELECT url, short_url FROM %s WHERE user_id = $1 AND is_deleted = false", tableName)
        rows, err := us.conn.Query(us.ctx, query, uniqueID)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var responseUrls []UserUrlsResponseBodyItem

        for rows.Next() </span><span class="cov0" title="0">{
                var url string
                var shortURL string
                var responseItem UserUrlsResponseBodyItem

                if err := rows.Scan(&amp;url, &amp;shortURL); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">responseItem.OriginalURL = url
                responseItem.ShortURL = shortURL

                responseUrls = append(responseUrls, responseItem)</span>
        }

        <span class="cov0" title="0">return responseUrls, nil</span>
}

func (us *UsersStorage) DeleteUserUrls(uniqueID string, shortURLS []string) error <span class="cov0" title="0">{
        batch := &amp;pgx.Batch{}
        for _, shortURL := range shortURLS </span><span class="cov0" title="0">{
                batch.Queue(
                        "UPDATE urls SET is_deleted = true WHERE short_url = $1 AND user_id = $2", shortURL, uniqueID)
        }</span>

        <span class="cov0" title="0">br := us.conn.SendBatch(context.Background(), batch)
        defer br.Close()

        for i := 0; i &lt; len(shortURLS); i++ </span><span class="cov0" title="0">{
                _, err := br.Exec()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (us *UsersStorage) Init(connectionString string) error <span class="cov0" title="0">{
        us.ctx = context.Background()
        var err error
        us.conn, err = pgxpool.Connect(us.ctx, connectionString)

        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error while initializing db connection: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (us *UsersStorage) Close() <span class="cov0" title="0">{
        us.conn.Close()
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
